#!/bin/bash
#
# build_app.sh - Complete build system for YouTube 4K Downloader
# 
# This script handles:
#   - Generating setup.py configuration
#   - Updating yt-dlp to the latest version
#   - Building the macOS app with py2app
#   - Bundling ffmpeg and deno for a self-contained app
#   - Installing to Applications folder
#
# Usage:
#   ./build_app.sh                      # Build with current .py file
#   ./build_app.sh yt_dlp_gui_v18.py    # Build with a new version
#   ./build_app.sh --update-ytdlp       # Just update yt-dlp, no build
#   ./build_app.sh --help               # Show help
#
# Author: bytePatrol
#

# ============================================================================
# CONFIGURATION
# ============================================================================

# Auto-detect project directory (where this script is located)
PROJECT_DIR="$(cd "$(dirname "$0")" && pwd)"
VENV_DIR="$PROJECT_DIR/venv"
MAIN_SCRIPT="yt_dlp_gui_v17.7.3.py"  # Default script name
APP_NAME="YouTube 4K Downloader"
BUNDLE_ID="com.bytepatrol.youtube4kdownloader"
INSTALL_DIR="/Applications"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Global variable to store built app path
BUILT_APP_PATH=""

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

print_header() {
    echo ""
    echo -e "${CYAN}==========================================${NC}"
    echo -e "${CYAN}$1${NC}"
    echo -e "${CYAN}==========================================${NC}"
    echo ""
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

show_help() {
    echo ""
    echo "YouTube 4K Downloader Build Script"
    echo ""
    echo "Usage:"
    echo "  ./build_app.sh                      Build with current .py file"
    echo "  ./build_app.sh <file.py>            Build with a new Python file"
    echo "  ./build_app.sh --update-ytdlp       Just update yt-dlp (no build)"
    echo "  ./build_app.sh --check-updates      Check for yt-dlp updates"
    echo "  ./build_app.sh --clean              Clean build artifacts"
    echo "  ./build_app.sh --help               Show this help"
    echo ""
    echo "Examples:"
    echo "  ./build_app.sh yt_dlp_gui_v18.py    Build new version"
    echo "  ./build_app.sh --update-ytdlp       Update yt-dlp before building"
    echo ""
}

activate_venv() {
    if [ ! -f "$VENV_DIR/bin/activate" ]; then
        print_warning "Virtual environment not found at $VENV_DIR"
        print_info "Creating virtual environment..."
        
        python3 -m venv "$VENV_DIR"
        
        if [ $? -ne 0 ]; then
            print_error "Failed to create virtual environment"
            exit 1
        fi
        
        print_success "Virtual environment created"
        
        # Activate and install dependencies
        source "$VENV_DIR/bin/activate"
        
        print_info "Installing required packages..."
        pip install --upgrade pip
        pip install py2app customtkinter pillow requests yt-dlp
        
        if [ $? -ne 0 ]; then
            print_error "Failed to install dependencies"
            exit 1
        fi
        
        print_success "All dependencies installed"
    else
        source "$VENV_DIR/bin/activate"
        print_success "Virtual environment activated"
    fi
}

deactivate_venv() {
    if command -v deactivate &> /dev/null; then
        deactivate 2>/dev/null || true
    fi
}

# ============================================================================
# GENERATE SETUP.PY
# ============================================================================

generate_setup_py() {
    local PY_FILE="$1"
    local VERSION="$2"
    
    print_info "Generating setup.py for $PY_FILE (v$VERSION)"
    
    cat > "$PROJECT_DIR/setup.py" << SETUP_EOF
"""
Setup script for creating a macOS .app bundle for YouTube 4K Downloader
Auto-generated by build_app.sh
"""

from setuptools import setup
import os

# Path to your app icon (in assets folder)
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
ICON_PATH = os.path.join(SCRIPT_DIR, 'assets', 'icon.icns')

# Verify icon exists
if os.path.isfile(ICON_PATH):
    print(f"‚úÖ Found icon at: {ICON_PATH}")
else:
    print(f"‚ö†Ô∏è  Icon not found at: {ICON_PATH}")
    ICON_PATH = None

APP = ['$PY_FILE']
DATA_FILES = []  # ffmpeg and deno are bundled by build_app.sh

OPTIONS = {
    'argv_emulation': False,
    'iconfile': ICON_PATH,
    'plist': {
        'CFBundleName': '$APP_NAME',
        'CFBundleDisplayName': '$APP_NAME',
        'CFBundleGetInfoString': "Modern YouTube downloader for macOS - 100% Standalone",
        'CFBundleIdentifier': "$BUNDLE_ID",
        'CFBundleVersion': "$VERSION",
        'CFBundleShortVersionString': "$VERSION",
        'NSHumanReadableCopyright': "Copyright ¬© 2025 bytePatrol. All rights reserved.",
        'NSHighResolutionCapable': True,
        'LSMinimumSystemVersion': '10.13',
    },
    'packages': [
        'customtkinter',
        'tkinter',
        'PIL',
        'requests',
        'certifi',
        'charset_normalizer',
        'yt_dlp',
    ],
    'includes': [
        'subprocess',
        'json',
        'threading',
        'queue',
        'pathlib',
    ],
    'excludes': [
        'numpy',
        'scipy',
        'matplotlib',
        'pandas',
    ],
    'semi_standalone': False,
    'site_packages': True,
}

setup(
    name='$APP_NAME',
    app=APP,
    data_files=DATA_FILES,
    options={'py2app': OPTIONS},
    setup_requires=['py2app'],
)
SETUP_EOF

    print_success "setup.py generated"
}

# ============================================================================
# UPDATE YT-DLP
# ============================================================================

check_ytdlp_updates() {
    print_header "Checking for yt-dlp Updates"
    
    activate_venv
    
    CURRENT_VERSION=$(pip show yt-dlp 2>/dev/null | grep "Version:" | awk '{print $2}')
    echo "Current version: $CURRENT_VERSION"
    
    # Check PyPI for latest version
    LATEST_VERSION=$(pip index versions yt-dlp 2>/dev/null | grep -oE '[0-9]{4}\.[0-9]{1,2}\.[0-9]{1,2}' | head -1)
    
    if [ -z "$LATEST_VERSION" ]; then
        # Fallback method
        LATEST_VERSION=$(pip install yt-dlp== 2>&1 | grep -oE '[0-9]{4}\.[0-9]{1,2}\.[0-9]{1,2}' | tail -1)
    fi
    
    echo "Latest version:  $LATEST_VERSION"
    
    deactivate_venv
    
    if [ "$CURRENT_VERSION" = "$LATEST_VERSION" ]; then
        print_success "yt-dlp is up to date!"
        return 1  # No update needed
    else
        print_warning "Update available: $CURRENT_VERSION ‚Üí $LATEST_VERSION"
        return 0  # Update available
    fi
}

update_ytdlp() {
    print_header "Updating yt-dlp"
    
    activate_venv
    
    BEFORE_VERSION=$(pip show yt-dlp 2>/dev/null | grep "Version:" | awk '{print $2}')
    print_info "Current version: $BEFORE_VERSION"
    
    echo ""
    echo "Updating yt-dlp..."
    pip install --upgrade yt-dlp
    
    AFTER_VERSION=$(pip show yt-dlp 2>/dev/null | grep "Version:" | awk '{print $2}')
    
    echo ""
    if [ "$BEFORE_VERSION" = "$AFTER_VERSION" ]; then
        print_success "yt-dlp is already at the latest version: $AFTER_VERSION"
    else
        print_success "yt-dlp updated: $BEFORE_VERSION ‚Üí $AFTER_VERSION"
    fi
    
    deactivate_venv
}

# ============================================================================
# CLEAN BUILD
# ============================================================================

clean_build() {
    print_header "Cleaning Build Artifacts"
    
    cd "$PROJECT_DIR"
    
    if [ -d "build" ]; then
        rm -rf build
        print_success "Removed build/"
    fi
    
    if [ -d "dist" ]; then
        rm -rf dist
        print_success "Removed dist/"
    fi
    
    # Remove .pyc files
    find . -type f -name "*.pyc" -delete 2>/dev/null || true
    find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
    
    print_success "Clean complete"
}

# ============================================================================
# BUNDLE DEPENDENCIES (ffmpeg + deno)
# ============================================================================

bundle_dependencies() {
    local APP_PATH="$1"
    local RESOURCES_DIR="$APP_PATH/Contents/Resources"
    
    print_header "Bundling Dependencies (ffmpeg + deno)"
    
    echo "App path: $APP_PATH"
    echo "Resources dir: $RESOURCES_DIR"
    
    if [ ! -d "$APP_PATH" ]; then
        print_error "App not found at: $APP_PATH"
        echo "Contents of dist/:"
        ls -la "$PROJECT_DIR/dist/" 2>/dev/null || echo "dist/ not found"
        return 1
    fi
    
    if [ ! -d "$RESOURCES_DIR" ]; then
        print_error "Resources directory not found at: $RESOURCES_DIR"
        return 1
    fi
    
    TEMP_DIR=$(mktemp -d)
    cd "$TEMP_DIR"
    
    # --- Install FFmpeg ---
    echo ""
    echo "üì• Downloading static ffmpeg..."
    if curl -L --progress-bar "https://evermeet.cx/ffmpeg/getrelease/ffmpeg/zip" -o ffmpeg.zip; then
        unzip -q ffmpeg.zip
        
        if [ -f "ffmpeg" ]; then
            cp ffmpeg "$RESOURCES_DIR/ffmpeg"
            chmod +x "$RESOURCES_DIR/ffmpeg"
            print_success "FFmpeg installed ($(ls -lh "$RESOURCES_DIR/ffmpeg" | awk '{print $5}'))"
        else
            print_error "FFmpeg not found in zip"
            cd /
            rm -rf "$TEMP_DIR"
            return 1
        fi
    else
        print_error "FFmpeg download failed"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # --- Install Deno ---
    ARCH=$(uname -m)
    if [ "$ARCH" = "arm64" ]; then
        DENO_ARCH="aarch64"
    else
        DENO_ARCH="x86_64"
    fi
    
    echo ""
    echo "üì• Downloading deno for $DENO_ARCH..."
    if curl -L --progress-bar "https://github.com/denoland/deno/releases/latest/download/deno-${DENO_ARCH}-apple-darwin.zip" -o deno.zip; then
        unzip -q -o deno.zip
        
        if [ -f "deno" ]; then
            cp deno "$RESOURCES_DIR/deno"
            chmod +x "$RESOURCES_DIR/deno"
            print_success "Deno installed ($(ls -lh "$RESOURCES_DIR/deno" | awk '{print $5}'))"
        else
            print_error "Deno not found in zip"
            cd /
            rm -rf "$TEMP_DIR"
            return 1
        fi
    else
        print_error "Deno download failed"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Cleanup
    cd /
    rm -rf "$TEMP_DIR"
    
    echo ""
    print_success "All dependencies bundled successfully!"
    return 0
}

# ============================================================================
# BUILD APP
# ============================================================================

build_app() {
    local PY_FILE="$1"
    
    print_header "Building $APP_NAME"
    
    cd "$PROJECT_DIR"
    
    # Check if Python file exists
    if [ ! -f "$PY_FILE" ]; then
        print_error "Python file not found: $PY_FILE"
        exit 1
    fi
    
    print_info "Source: $PY_FILE"
    
    # Extract version from the Python file
    VERSION=$(grep -E "^APP_VERSION\s*=" "$PY_FILE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    if [ -z "$VERSION" ]; then
        VERSION="1.0.0"
    fi
    print_info "Version: $VERSION"
    
    # Generate setup.py with current settings
    generate_setup_py "$PY_FILE" "$VERSION"
    
    # Clean previous build
    clean_build
    
    # Activate venv and build
    activate_venv
    
    echo ""
    echo "Running py2app..."
    echo ""
    python setup.py py2app
    
    BUILD_RESULT=$?
    
    deactivate_venv
    
    if [ $BUILD_RESULT -ne 0 ]; then
        print_error "py2app build failed"
        exit 1
    fi
    
    # Find the built app - handle spaces in name properly
    echo ""
    echo "Looking for built app in dist/..."
    ls -la "$PROJECT_DIR/dist/"
    
    # Use find with -print0 and read to handle spaces
    BUILT_APP_PATH=""
    while IFS= read -r -d '' app; do
        BUILT_APP_PATH="$app"
        break
    done < <(find "$PROJECT_DIR/dist" -maxdepth 1 -name "*.app" -type d -print0 2>/dev/null)
    
    if [ -z "$BUILT_APP_PATH" ]; then
        print_error "No .app found in dist/"
        exit 1
    fi
    
    print_success "App built: $BUILT_APP_PATH"
    
    # Bundle dependencies
    if ! bundle_dependencies "$BUILT_APP_PATH"; then
        print_error "Failed to bundle dependencies"
        exit 1
    fi
    
    # Show final app size
    echo ""
    APP_SIZE=$(du -sh "$BUILT_APP_PATH" | cut -f1)
    print_success "Build complete! App size: $APP_SIZE"
}

# ============================================================================
# INSTALL APP
# ============================================================================

install_app() {
    local SOURCE_APP="$1"
    
    print_header "Installing to $INSTALL_DIR"
    
    if [ ! -d "$SOURCE_APP" ]; then
        print_error "Source app not found: $SOURCE_APP"
        return 1
    fi
    
    # Get the app name from the source
    APP_BASENAME=$(basename "$SOURCE_APP")
    INSTALL_PATH="$INSTALL_DIR/$APP_BASENAME"
    
    print_info "Installing: $APP_BASENAME"
    
    # Remove old installation if exists
    if [ -d "$INSTALL_PATH" ]; then
        print_warning "Removing existing installation..."
        rm -rf "$INSTALL_PATH"
    fi
    
    # Copy new app
    cp -R "$SOURCE_APP" "$INSTALL_DIR/"
    
    if [ -d "$INSTALL_PATH" ]; then
        print_success "Installed to: $INSTALL_PATH"
        
        # Verify ffmpeg and deno are present
        if [ -f "$INSTALL_PATH/Contents/Resources/ffmpeg" ]; then
            print_success "ffmpeg verified ‚úì"
        else
            print_warning "ffmpeg not found in installed app!"
        fi
        
        if [ -f "$INSTALL_PATH/Contents/Resources/deno" ]; then
            print_success "deno verified ‚úì"
        else
            print_warning "deno not found in installed app!"
        fi
    else
        print_error "Installation failed"
        return 1
    fi
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    echo ""
    echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${CYAN}‚ïë   YouTube 4K Downloader Build System   ‚ïë${NC}"
    echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    
    # Parse arguments
    case "${1:-}" in
        --help|-h)
            show_help
            exit 0
            ;;
        --update-ytdlp)
            update_ytdlp
            exit 0
            ;;
        --check-updates)
            check_ytdlp_updates
            exit 0
            ;;
        --clean)
            clean_build
            exit 0
            ;;
        *.py)
            # New Python file provided
            if [ -f "$1" ]; then
                print_info "Using Python file: $1"
                MAIN_SCRIPT=$(basename "$1")
                # Copy if source is different from destination
                SOURCE_PATH="$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"
                DEST_PATH="$PROJECT_DIR/$MAIN_SCRIPT"
                if [ "$SOURCE_PATH" != "$DEST_PATH" ]; then
                    cp "$1" "$PROJECT_DIR/"
                    print_success "Copied to project folder"
                else
                    print_info "File already in project folder"
                fi
            else
                print_error "File not found: $1"
                exit 1
            fi
            ;;
        "")
            # No arguments - use default/existing script
            print_info "Using existing script: $MAIN_SCRIPT"
            ;;
        *)
            print_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
    
    # Check for yt-dlp updates
    echo ""
    if check_ytdlp_updates; then
        echo ""
        read -p "Update yt-dlp before building? (y/n) " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            update_ytdlp
        fi
    fi
    
    # Build the app
    cd "$PROJECT_DIR"
    build_app "$MAIN_SCRIPT"
    
    # Ask to install
    echo ""
    read -p "Install to $INSTALL_DIR? (y/n) " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        install_app "$BUILT_APP_PATH"
    fi
    
    # Done!
    print_header "Build Complete!"
    
    echo "Your app is ready:"
    echo ""
    echo "  üìÅ Built app:  $BUILT_APP_PATH"
    
    APP_BASENAME=$(basename "$BUILT_APP_PATH")
    if [ -d "$INSTALL_DIR/$APP_BASENAME" ]; then
        echo "  üìÅ Installed:  $INSTALL_DIR/$APP_BASENAME"
    fi
    echo ""
    print_success "Done! üéâ"
}

# Run main
main "$@"
