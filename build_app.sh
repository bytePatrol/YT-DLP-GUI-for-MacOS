#!/bin/bash
#
# build_app.sh - Complete build system for YouTube 4K Downloader
# 
# This script handles:
#   - Generating setup.py configuration
#   - Updating yt-dlp to the latest version
#   - Building the macOS app with py2app
#   - Bundling ffmpeg and deno for a self-contained app
#   - Installing to Applications folder
#
# Usage:
#   ./build_app.sh                      # Build with current .py file
#   ./build_app.sh yt_dlp_gui_v18.py    # Build with a new version
#   ./build_app.sh --update-ytdlp       # Just update yt-dlp, no build
#   ./build_app.sh --help               # Show help
#
# Author: bytePatrol
#

# ============================================================================
# CONFIGURATION
# ============================================================================

# Auto-detect project directory (where this script is located)
PROJECT_DIR="$(cd "$(dirname "$0")" && pwd)"
VENV_DIR="$PROJECT_DIR/venv"
MAIN_SCRIPT="yt_dlp_gui_v18_0_7.py"  # Default script name
APP_NAME="YouTube 4K Downloader"
BUNDLE_ID="com.bytepatrol.youtube4kdownloader"
INSTALL_DIR="/Applications"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Global variable to store built app path
BUILT_APP_PATH=""

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

print_header() {
    echo ""
    echo -e "${CYAN}==========================================${NC}"
    echo -e "${CYAN}$1${NC}"
    echo -e "${CYAN}==========================================${NC}"
    echo ""
}

print_success() {
    echo -e "${GREEN}[OK] $1${NC}"
}

print_error() {
    echo -e "${RED}[ERROR] $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}[WARN] $1${NC}"
}

print_info() {
    echo -e "${BLUE}[INFO] $1${NC}"
}

show_help() {
    echo ""
    echo "YouTube 4K Downloader Build Script"
    echo ""
    echo "Usage:"
    echo "  ./build_app.sh                      Build with current .py file"
    echo "  ./build_app.sh <file.py>            Build with a new Python file"
    echo "  ./build_app.sh --update-ytdlp       Just update yt-dlp (no build)"
    echo "  ./build_app.sh --check-updates      Check for yt-dlp updates"
    echo "  ./build_app.sh --clean              Clean build artifacts"
    echo "  ./build_app.sh --help               Show this help"
    echo ""
    echo "Examples:"
    echo "  ./build_app.sh yt_dlp_gui_v18.py    Build new version"
    echo "  ./build_app.sh --update-ytdlp       Update yt-dlp before building"
    echo ""
}

activate_venv() {
    if [ ! -f "$VENV_DIR/bin/activate" ]; then
        print_warning "Virtual environment not found at $VENV_DIR"
        print_info "Creating virtual environment..."
        
        /opt/homebrew/opt/python@3.13/bin/python3.13 -m venv "$VENV_DIR"
        
        if [ $? -ne 0 ]; then
            print_error "Failed to create virtual environment"
            exit 1
        fi
        
        print_success "Virtual environment created"
        
        # Activate and install dependencies
        source "$VENV_DIR/bin/activate"
        
        print_info "Installing required packages..."
        pip install --upgrade pip
        pip install py2app customtkinter pillow requests yt-dlp darkdetect idna urllib3 charset-normalizer certifi psutil
        
        if [ $? -ne 0 ]; then
            print_error "Failed to install dependencies"
            exit 1
        fi
        
        print_success "All dependencies installed"
    else
        source "$VENV_DIR/bin/activate"
        print_success "Virtual environment activated"
        
        # Check if psutil is installed (required for v18.0.0+)
        if ! python -c "import psutil" 2>/dev/null; then
            print_warning "psutil not found in existing venv, installing..."
            pip install psutil
            if [ $? -ne 0 ]; then
                print_error "Failed to install psutil"
                exit 1
            fi
            print_success "psutil installed"
        fi
    fi
}

deactivate_venv() {
    if command -v deactivate &> /dev/null; then
        deactivate 2>/dev/null || true
    fi
}

# ============================================================================
# GENERATE SETUP.PY
# ============================================================================

generate_setup_py() {
    local PY_FILE="$1"
    local VERSION="$2"
    
    print_info "Generating setup.py for $PY_FILE (v$VERSION)"
    
    cat > "$PROJECT_DIR/setup.py" << 'SETUP_EOF'
"""
Setup script for creating a macOS .app bundle for YouTube 4K Downloader
Auto-generated by build_app.sh
"""

from setuptools import setup
import os
import sys
import tkinter
import shutil

# Path to your app icon (in assets folder)
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
ICON_PATH = os.path.join(SCRIPT_DIR, 'assets', 'icon.icns')

# Verify icon exists
if os.path.isfile(ICON_PATH):
    print(f"[OK] Found icon at: {ICON_PATH}")
else:
    print(f"[WARN] Icon not found at: {ICON_PATH}")
    ICON_PATH = None

# Find Tcl/Tk library paths for bundling
def find_tcl_tk():
    """Find Tcl/Tk frameworks/libraries to bundle."""
    tcl_paths = []
    
    # Get the Tcl/Tk library that Python is actually using
    try:
        tcl_lib = tkinter.Tcl().eval('info library')
        if tcl_lib and os.path.exists(tcl_lib):
            # Get parent directories to find the framework
            tcl_root = os.path.dirname(os.path.dirname(tcl_lib))
            if os.path.exists(tcl_root):
                print(f"[OK] Found Tcl at: {tcl_root}")
                tcl_paths.append(tcl_root)
    except Exception as e:
        print(f"[WARN] Could not detect Tcl/Tk path: {e}")
    
    # Also check common Homebrew locations
    homebrew_paths = [
        '/opt/homebrew/opt/tcl-tk/lib',  # Apple Silicon
        '/usr/local/opt/tcl-tk/lib',      # Intel
    ]
    for path in homebrew_paths:
        if os.path.isdir(path):
            print(f"[OK] Found Homebrew Tcl/Tk at: {path}")
            tcl_paths.append(path)
            break
    
    return tcl_paths

tcl_tk_paths = find_tcl_tk()

SETUP_EOF

    # Now append the rest with variable substitution
    cat >> "$PROJECT_DIR/setup.py" << SETUP_EOF

APP = ['$PY_FILE']
DATA_FILES = []

# Build frameworks list for Tcl/Tk
frameworks_to_include = []
for tcl_path in tcl_tk_paths:
    tcl_fw = os.path.join(tcl_path, 'Tcl.framework')
    tk_fw = os.path.join(tcl_path, 'Tk.framework')
    if os.path.isdir(tcl_fw):
        frameworks_to_include.append(tcl_fw)
    if os.path.isdir(tk_fw):
        frameworks_to_include.append(tk_fw)

if frameworks_to_include:
    print(f"[OK] Will bundle frameworks: {frameworks_to_include}")

OPTIONS = {
    'argv_emulation': False,
    'iconfile': ICON_PATH,
    'plist': {
        'CFBundleName': '$APP_NAME',
        'CFBundleDisplayName': '$APP_NAME',
        'CFBundleGetInfoString': "Modern YouTube downloader for macOS - 100% Standalone",
        'CFBundleIdentifier': "$BUNDLE_ID",
        'CFBundleVersion': "$VERSION",
        'CFBundleShortVersionString': "$VERSION",
        'NSHumanReadableCopyright': "Copyright 2025 bytePatrol. All rights reserved.",
        'NSHighResolutionCapable': True,
        'LSMinimumSystemVersion': '10.13',
    },
    'frameworks': [],  # Don't bundle Tcl/Tk - let system handle it
    'packages': [
        'customtkinter',
        'tkinter',
        'PIL',
        'requests',
        'certifi',
        'charset_normalizer',
        'yt_dlp',
        'idna',
        'urllib3',
        'darkdetect',
        'psutil',
    ],
    'includes': [
        'subprocess',
        'json',
        'threading',
        'queue',
        'pathlib',
        'dataclasses',
        'typing',
        'enum',
        'hashlib',
        'tempfile',
        'shlex',
        'urllib.request',
        '_tkinter',
        'tkinter',
        'tkinter.ttk',
        'tkinter.filedialog',
        'tkinter.messagebox',
        'PIL.Image',
        'PIL.ImageTk',
    ],
    'excludes': [
        'numpy',
        'scipy',
        'matplotlib',
        'pandas',
        'IPython',
        'jupyter',
        'notebook',
        'test',
        'tests',
    ],
    'semi_standalone': False,
    'site_packages': True,
    'strip': False,
}

setup(
    name='$APP_NAME',
    app=APP,
    data_files=DATA_FILES,
    options={'py2app': OPTIONS},
    setup_requires=['py2app'],
)
SETUP_EOF

    print_success "setup.py generated"
}

# ============================================================================
# UPDATE YT-DLP
# ============================================================================

check_ytdlp_updates() {
    print_header "Checking for yt-dlp Updates"
    
    activate_venv
    
    CURRENT_VERSION=$(pip show yt-dlp 2>/dev/null | grep "Version:" | awk '{print $2}')
    echo "Current version: $CURRENT_VERSION"
    
    # Check PyPI for latest version
    LATEST_VERSION=$(pip index versions yt-dlp 2>/dev/null | grep -oE '[0-9]{4}\.[0-9]{1,2}\.[0-9]{1,2}' | head -1)
    
    if [ -z "$LATEST_VERSION" ]; then
        # Fallback method
        LATEST_VERSION=$(pip install yt-dlp== 2>&1 | grep -oE '[0-9]{4}\.[0-9]{1,2}\.[0-9]{1,2}' | tail -1)
    fi
    
    echo "Latest version:  $LATEST_VERSION"
    
    deactivate_venv
    
    if [ "$CURRENT_VERSION" = "$LATEST_VERSION" ]; then
        print_success "yt-dlp is up to date!"
        return 1  # No update needed
    else
        print_warning "Update available: $CURRENT_VERSION -> $LATEST_VERSION"
        return 0  # Update available
    fi
}

update_ytdlp() {
    print_header "Updating yt-dlp"
    
    activate_venv
    
    BEFORE_VERSION=$(pip show yt-dlp 2>/dev/null | grep "Version:" | awk '{print $2}')
    print_info "Current version: $BEFORE_VERSION"
    
    echo ""
    echo "Updating yt-dlp..."
    pip install --upgrade yt-dlp
    
    AFTER_VERSION=$(pip show yt-dlp 2>/dev/null | grep "Version:" | awk '{print $2}')
    
    echo ""
    if [ "$BEFORE_VERSION" = "$AFTER_VERSION" ]; then
        print_success "yt-dlp is already at the latest version: $AFTER_VERSION"
    else
        print_success "yt-dlp updated: $BEFORE_VERSION -> $AFTER_VERSION"
    fi
    
    deactivate_venv
}

# ============================================================================
# CLEAN BUILD
# ============================================================================

clean_build() {
    print_header "Cleaning Build Artifacts"
    
    cd "$PROJECT_DIR"
    
    if [ -d "build" ]; then
        rm -rf build
        print_success "Removed build/"
    fi
    
    if [ -d "dist" ]; then
        rm -rf dist
        print_success "Removed dist/"
    fi
    
    # Remove .pyc files
    find . -type f -name "*.pyc" -delete 2>/dev/null || true
    find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
    
    print_success "Clean complete"
}

# ============================================================================
# BUNDLE DEPENDENCIES (ffmpeg + deno + Tcl/Tk)
# ============================================================================

bundle_dependencies() {
    local APP_PATH="$1"
    local RESOURCES_DIR="$APP_PATH/Contents/Resources"
    local FRAMEWORKS_DIR="$APP_PATH/Contents/Frameworks"
    
    print_header "Bundling Dependencies (ffmpeg + deno)"
    
    echo "App path: $APP_PATH"
    echo "Resources dir: $RESOURCES_DIR"
    
    if [ ! -d "$APP_PATH" ]; then
        print_error "App not found at: $APP_PATH"
        echo "Contents of dist/:"
        ls -la "$PROJECT_DIR/dist/" 2>/dev/null || echo "dist/ not found"
        return 1
    fi
    
    if [ ! -d "$RESOURCES_DIR" ]; then
        print_error "Resources directory not found at: $RESOURCES_DIR"
        return 1
    fi
    
    # Create Frameworks directory if it doesn't exist
    mkdir -p "$FRAMEWORKS_DIR"
    
    TEMP_DIR=$(mktemp -d)
    cd "$TEMP_DIR"
    
    # --- Bundle Tcl/Tk ---
    # This is CRITICAL for standalone apps - without this, the app will fail
    # on systems that don't have Homebrew's Tcl/Tk installed
    print_info "Bundling Tcl/Tk libraries..."
    
    # Find where Python's tkinter expects Tcl/Tk
    TCL_VERSION=""
    TCL_LIB_DIR=""
    
    # Check Homebrew locations (Apple Silicon and Intel)
    if [ -d "/opt/homebrew/opt/tcl-tk/lib" ]; then
        TCL_LIB_DIR="/opt/homebrew/opt/tcl-tk/lib"
        # Detect version (tcl9.0, tcl8.6, etc.)
        if [ -d "$TCL_LIB_DIR/tcl9.0" ]; then
            TCL_VERSION="9.0"
        elif [ -d "$TCL_LIB_DIR/tcl8.6" ]; then
            TCL_VERSION="8.6"
        fi
    elif [ -d "/usr/local/opt/tcl-tk/lib" ]; then
        TCL_LIB_DIR="/usr/local/opt/tcl-tk/lib"
        if [ -d "$TCL_LIB_DIR/tcl9.0" ]; then
            TCL_VERSION="9.0"
        elif [ -d "$TCL_LIB_DIR/tcl8.6" ]; then
            TCL_VERSION="8.6"
        fi
    fi
    
    if [ -n "$TCL_VERSION" ] && [ -n "$TCL_LIB_DIR" ]; then
        print_info "Found Tcl/Tk $TCL_VERSION at $TCL_LIB_DIR"
        
        # Create lib directory in app bundle
        mkdir -p "$APP_PATH/Contents/lib"
        
        # Copy Tcl library folder
        if [ -d "$TCL_LIB_DIR/tcl$TCL_VERSION" ]; then
            cp -R "$TCL_LIB_DIR/tcl$TCL_VERSION" "$APP_PATH/Contents/lib/"
            print_success "Copied tcl$TCL_VERSION library"
        fi
        
        # Copy Tk library folder
        if [ -d "$TCL_LIB_DIR/tk$TCL_VERSION" ]; then
            cp -R "$TCL_LIB_DIR/tk$TCL_VERSION" "$APP_PATH/Contents/lib/"
            print_success "Copied tk$TCL_VERSION library"
        fi
        
        # Copy dynamic libraries (.dylib files)
        mkdir -p "$FRAMEWORKS_DIR"
        
        # Copy Tcl dylib
        for tcl_dylib in "$TCL_LIB_DIR"/libtcl*.dylib; do
            if [ -f "$tcl_dylib" ]; then
                cp "$tcl_dylib" "$FRAMEWORKS_DIR/"
                print_success "Copied $(basename "$tcl_dylib")"
            fi
        done
        
        # Copy Tk dylib
        for tk_dylib in "$TCL_LIB_DIR"/libtk*.dylib; do
            if [ -f "$tk_dylib" ]; then
                cp "$tk_dylib" "$FRAMEWORKS_DIR/"
                print_success "Copied $(basename "$tk_dylib")"
            fi
        done
        
        # Also check for tcl9 and tk9 specific dylibs (Tcl 9.0 naming)
        if [ -f "$TCL_LIB_DIR/libtcl9.0.dylib" ]; then
            cp "$TCL_LIB_DIR/libtcl9.0.dylib" "$FRAMEWORKS_DIR/"
        fi
        if [ -f "$TCL_LIB_DIR/libtk9.0.dylib" ]; then
            cp "$TCL_LIB_DIR/libtk9.0.dylib" "$FRAMEWORKS_DIR/"
        fi
        
        # --- Bundle Tcl/Tk dependencies (libtommath, etc.) ---
        # Tcl 9.0 depends on libtommath for big number support
        print_info "Bundling Tcl/Tk dependencies..."
        
        # Find and copy libtommath
        LIBTOMMATH_PATHS=(
            "/opt/homebrew/opt/libtommath/lib/libtommath.1.dylib"
            "/opt/homebrew/lib/libtommath.1.dylib"
            "/usr/local/opt/libtommath/lib/libtommath.1.dylib"
            "/usr/local/lib/libtommath.1.dylib"
        )
        
        LIBTOMMATH_FOUND=false
        for tommath_path in "${LIBTOMMATH_PATHS[@]}"; do
            if [ -f "$tommath_path" ]; then
                cp "$tommath_path" "$FRAMEWORKS_DIR/"
                print_success "Copied libtommath.1.dylib"
                LIBTOMMATH_FOUND=true
                
                # Also copy the unversioned symlink target if it exists
                tommath_dir=$(dirname "$tommath_path")
                if [ -f "$tommath_dir/libtommath.dylib" ]; then
                    cp "$tommath_dir/libtommath.dylib" "$FRAMEWORKS_DIR/" 2>/dev/null || true
                fi
                break
            fi
        done
        
        if [ "$LIBTOMMATH_FOUND" = false ]; then
            print_warning "libtommath not found - Tcl 9.0 may not work!"
            print_info "Install with: brew install libtommath"
        fi
        
        # Use otool to find ALL dependencies of bundled dylibs and copy them
        print_info "Checking for additional Tcl/Tk dependencies..."
        
        for dylib in "$FRAMEWORKS_DIR"/*.dylib; do
            if [ -f "$dylib" ]; then
                # Get all dependencies
                deps=$(otool -L "$dylib" 2>/dev/null | grep -E "^\s+/opt/homebrew|^\s+/usr/local" | awk '{print $1}')
                
                for dep in $deps; do
                    dep_name=$(basename "$dep")
                    
                    # Skip if already copied
                    if [ -f "$FRAMEWORKS_DIR/$dep_name" ]; then
                        continue
                    fi
                    
                    # Copy the dependency
                    if [ -f "$dep" ]; then
                        cp "$dep" "$FRAMEWORKS_DIR/"
                        print_success "Copied dependency: $dep_name"
                    fi
                done
            fi
        done
        
        # --- Fix library paths using install_name_tool ---
        # Change hardcoded Homebrew paths to use @executable_path/../Frameworks
        print_info "Fixing library paths for standalone use..."
        
        for dylib in "$FRAMEWORKS_DIR"/*.dylib; do
            if [ -f "$dylib" ]; then
                dylib_name=$(basename "$dylib")
                
                # Change the install name of this library to use @rpath
                install_name_tool -id "@rpath/$dylib_name" "$dylib" 2>/dev/null || true
                
                # Find and fix references to Homebrew paths
                deps=$(otool -L "$dylib" 2>/dev/null | grep -E "^\s+/opt/homebrew|^\s+/usr/local" | awk '{print $1}')
                
                for dep in $deps; do
                    dep_name=$(basename "$dep")
                    # Change the path to use @rpath
                    install_name_tool -change "$dep" "@rpath/$dep_name" "$dylib" 2>/dev/null || true
                done
            fi
        done
        
        print_success "Library paths fixed for standalone deployment"
        
        # --- Also fix _tkinter.so in the app bundle ---
        # The _tkinter Python module also has hardcoded paths
        print_info "Fixing _tkinter.so library paths..."
        
        TKINTER_SO=$(find "$APP_PATH/Contents/Resources" -name "_tkinter*.so" -o -name "_tkinter*.dylib" 2>/dev/null | head -1)
        
        if [ -n "$TKINTER_SO" ] && [ -f "$TKINTER_SO" ]; then
            print_info "Found _tkinter at: $TKINTER_SO"
            
            # Get dependencies and fix them
            deps=$(otool -L "$TKINTER_SO" 2>/dev/null | grep -E "^\s+/opt/homebrew|^\s+/usr/local" | awk '{print $1}')
            
            for dep in $deps; do
                dep_name=$(basename "$dep")
                
                # Make sure the dependency is in Frameworks
                if [ ! -f "$FRAMEWORKS_DIR/$dep_name" ] && [ -f "$dep" ]; then
                    cp "$dep" "$FRAMEWORKS_DIR/"
                    print_success "Copied missing dependency: $dep_name"
                fi
                
                # Fix the path in _tkinter.so
                install_name_tool -change "$dep" "@rpath/$dep_name" "$TKINTER_SO" 2>/dev/null || true
            done
            
            # Add rpath to _tkinter.so so it can find Frameworks
            install_name_tool -add_rpath "@executable_path/../Frameworks" "$TKINTER_SO" 2>/dev/null || true
            install_name_tool -add_rpath "@loader_path/../../Frameworks" "$TKINTER_SO" 2>/dev/null || true
            
            print_success "_tkinter.so paths fixed"
        else
            print_warning "_tkinter.so not found - may need manual fixing"
        fi
        
        # --- Fix all .so files in lib-dynload ---
        print_info "Fixing all Python extension modules..."
        
        LIB_DYNLOAD=$(find "$APP_PATH/Contents/Resources" -type d -name "lib-dynload" 2>/dev/null | head -1)
        
        if [ -n "$LIB_DYNLOAD" ] && [ -d "$LIB_DYNLOAD" ]; then
            for so_file in "$LIB_DYNLOAD"/*.so; do
                if [ -f "$so_file" ]; then
                    # Add rpath
                    install_name_tool -add_rpath "@executable_path/../Frameworks" "$so_file" 2>/dev/null || true
                    
                    # Fix any Homebrew dependencies
                    deps=$(otool -L "$so_file" 2>/dev/null | grep -E "^\s+/opt/homebrew|^\s+/usr/local" | awk '{print $1}')
                    
                    for dep in $deps; do
                        dep_name=$(basename "$dep")
                        
                        # Copy if not already in Frameworks
                        if [ ! -f "$FRAMEWORKS_DIR/$dep_name" ] && [ -f "$dep" ]; then
                            cp "$dep" "$FRAMEWORKS_DIR/"
                            print_success "Copied: $dep_name"
                        fi
                        
                        # Fix the reference
                        install_name_tool -change "$dep" "@rpath/$dep_name" "$so_file" 2>/dev/null || true
                    done
                fi
            done
            print_success "All extension modules fixed"
        fi
        
        print_info "Tcl/Tk bundled successfully"
    else
        print_warning "Could not find Homebrew Tcl/Tk installation"
        print_warning "The app may not work on systems without Tcl/Tk installed"
        print_info "Install with: brew install tcl-tk"
    fi
    
    # --- Install FFmpeg ---
    echo ""
    echo "Downloading static ffmpeg..."
    if curl -L --progress-bar "https://evermeet.cx/ffmpeg/getrelease/ffmpeg/zip" -o ffmpeg.zip; then
        unzip -q ffmpeg.zip
        
        if [ -f "ffmpeg" ]; then
            cp ffmpeg "$RESOURCES_DIR/ffmpeg"
            chmod +x "$RESOURCES_DIR/ffmpeg"
            print_success "FFmpeg installed ($(ls -lh "$RESOURCES_DIR/ffmpeg" | awk '{print $5}'))"
        else
            print_error "FFmpeg not found in zip"
            cd /
            rm -rf "$TEMP_DIR"
            return 1
        fi
    else
        print_error "FFmpeg download failed"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # --- Install Deno ---
    ARCH=$(uname -m)
    if [ "$ARCH" = "arm64" ]; then
        DENO_ARCH="aarch64"
    else
        DENO_ARCH="x86_64"
    fi
    
    echo ""
    echo "Downloading deno for $DENO_ARCH..."
    if curl -L --progress-bar "https://github.com/denoland/deno/releases/latest/download/deno-${DENO_ARCH}-apple-darwin.zip" -o deno.zip; then
        unzip -q -o deno.zip
        
        if [ -f "deno" ]; then
            cp deno "$RESOURCES_DIR/deno"
            chmod +x "$RESOURCES_DIR/deno"
            print_success "Deno installed ($(ls -lh "$RESOURCES_DIR/deno" | awk '{print $5}'))"
        else
            print_error "Deno not found in zip"
            cd /
            rm -rf "$TEMP_DIR"
            return 1
        fi
    else
        print_error "Deno download failed"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Cleanup
    cd /
    rm -rf "$TEMP_DIR"
    
    echo ""
    print_success "All dependencies bundled successfully!"
    return 0
}

# ============================================================================
# VERIFY APP
# ============================================================================

verify_app() {
    local APP_PATH="$1"
    
    print_header "Verifying Built App"
    
    if [ ! -d "$APP_PATH" ]; then
        print_error "App not found at: $APP_PATH"
        return 1
    fi
    
    local RESOURCES_DIR="$APP_PATH/Contents/Resources"
    local FRAMEWORKS_DIR="$APP_PATH/Contents/Frameworks"
    local ERRORS=0
    
    # Check bundled executables
    echo "Checking bundled executables..."
    if [ -f "$RESOURCES_DIR/ffmpeg" ]; then
        print_success "ffmpeg present"
    else
        print_error "ffmpeg missing!"
        ERRORS=$((ERRORS + 1))
    fi
    
    if [ -f "$RESOURCES_DIR/deno" ]; then
        print_success "deno present"
    else
        print_error "deno missing!"
        ERRORS=$((ERRORS + 1))
    fi
    
    # Check for Tcl/Tk libraries
    echo ""
    echo "Checking Tcl/Tk libraries..."
    if [ -d "$APP_PATH/Contents/lib/tcl9.0" ] || [ -d "$APP_PATH/Contents/lib/tcl8.6" ]; then
        print_success "Tcl library present"
    else
        print_warning "Tcl library not found in Contents/lib/"
    fi
    
    if [ -d "$APP_PATH/Contents/lib/tk9.0" ] || [ -d "$APP_PATH/Contents/lib/tk8.6" ]; then
        print_success "Tk library present"
    else
        print_warning "Tk library not found in Contents/lib/"
    fi
    
    if ls "$FRAMEWORKS_DIR"/libtcl*.dylib 1> /dev/null 2>&1; then
        print_success "Tcl dylib present"
    else
        print_warning "Tcl dylib not found in Frameworks/"
    fi
    
    if ls "$FRAMEWORKS_DIR"/libtk*.dylib 1> /dev/null 2>&1; then
        print_success "Tk dylib present"
    else
        print_warning "Tk dylib not found in Frameworks/"
    fi
    
    # Check for Python packages in site-packages
    echo ""
    echo "Checking Python packages..."
    local SITE_PACKAGES=$(find "$APP_PATH/Contents/Resources/lib" -name "site-packages" -type d 2>/dev/null | head -1)
    
    if [ -n "$SITE_PACKAGES" ]; then
        local PACKAGES=("customtkinter" "PIL" "requests" "yt_dlp" "certifi")
        
        for pkg in "${PACKAGES[@]}"; do
            if [ -d "$SITE_PACKAGES/$pkg" ] || ls "$SITE_PACKAGES" | grep -qi "^${pkg}" 2>/dev/null; then
                print_success "$pkg"
            else
                print_error "$pkg missing!"
                ERRORS=$((ERRORS + 1))
            fi
        done
    else
        print_warning "Could not locate site-packages directory"
    fi
    
    # Check main executable
    echo ""
    echo "Checking main executable..."
    local EXECUTABLE="$APP_PATH/Contents/MacOS/$APP_NAME"
    if [ -f "$EXECUTABLE" ]; then
        local ARCH=$(file "$EXECUTABLE" | grep -o 'arm64\|x86_64' | head -1)
        local CURRENT_ARCH=$(uname -m)
        print_success "Executable found (architecture: $ARCH)"
        
        if [ "$ARCH" != "$CURRENT_ARCH" ]; then
            print_warning "Built for $ARCH but running on $CURRENT_ARCH"
        fi
    else
        print_error "Main executable not found!"
        ERRORS=$((ERRORS + 1))
    fi
    
    echo ""
    if [ $ERRORS -eq 0 ]; then
        print_success "All checks passed!"
        return 0
    else
        print_error "$ERRORS error(s) found - app may not launch correctly"
        return 1
    fi
}

# ============================================================================
# CODE SIGN APP (Ad-hoc signing to prevent "damaged" errors)
# ============================================================================

codesign_app() {
    local APP_PATH="$1"
    
    print_header "Code Signing App (Ad-hoc)"
    
    if [ ! -d "$APP_PATH" ]; then
        print_error "App not found: $APP_PATH"
        return 1
    fi
    
    echo "Signing with ad-hoc signature..."
    echo "(This prevents 'app is damaged' errors on other Macs)"
    echo ""
    
    # Remove any existing signatures and quarantine attributes
    xattr -cr "$APP_PATH" 2>/dev/null || true
    
    # Sign all nested components first (frameworks, dylibs, etc.)
    find "$APP_PATH" -type f \( -name "*.dylib" -o -name "*.so" -o -name "*.framework" \) -exec codesign --force --sign - {} \; 2>/dev/null || true
    
    # Sign the main executable
    codesign --force --deep --sign - "$APP_PATH" 2>&1
    
    if [ $? -eq 0 ]; then
        print_success "App signed successfully"
        
        # Verify signature
        if codesign --verify --verbose "$APP_PATH" 2>&1 | grep -q "valid"; then
            print_success "Signature verified"
        fi
    else
        print_warning "Code signing had issues (app may still work)"
    fi
    
    # Remove quarantine attribute (in case it got re-added)
    xattr -dr com.apple.quarantine "$APP_PATH" 2>/dev/null || true
    
    return 0
}

# ============================================================================
# SETUP TCL/TK ENVIRONMENT
# ============================================================================

setup_tcltk_environment() {
    local APP_PATH="$1"
    local RESOURCES_DIR="$APP_PATH/Contents/Resources"
    local MACOS_DIR="$APP_PATH/Contents/MacOS"
    
    print_header "Setting up Tcl/Tk Environment"
    
    # Detect which Tcl/Tk version was bundled
    TCL_VERSION=""
    if [ -d "$APP_PATH/Contents/lib/tcl9.0" ]; then
        TCL_VERSION="9.0"
    elif [ -d "$APP_PATH/Contents/lib/tcl8.6" ]; then
        TCL_VERSION="8.6"
    fi
    
    if [ -z "$TCL_VERSION" ]; then
        print_warning "No bundled Tcl/Tk found - skipping environment setup"
        return 0
    fi
    
    print_info "Found bundled Tcl/Tk $TCL_VERSION"
    
    # Find the main executable
    MAIN_EXECUTABLE=$(find "$MACOS_DIR" -type f -perm +111 ! -name "*.dylib" | head -1)
    
    if [ -z "$MAIN_EXECUTABLE" ]; then
        print_error "Could not find main executable in $MACOS_DIR"
        return 1
    fi
    
    EXECUTABLE_NAME=$(basename "$MAIN_EXECUTABLE")
    print_info "Main executable: $EXECUTABLE_NAME"
    
    # Rename original executable
    mv "$MAIN_EXECUTABLE" "${MAIN_EXECUTABLE}_real"
    
    # Create wrapper script that sets environment variables
    cat > "$MAIN_EXECUTABLE" << 'WRAPPER_SCRIPT'
#!/bin/bash
# Wrapper script to set Tcl/Tk environment variables
# Auto-generated by build_app.sh

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
APP_DIR="$(dirname "$SCRIPT_DIR")"

# Set Tcl/Tk library paths to the bundled versions
WRAPPER_SCRIPT

    # Add version-specific paths
    cat >> "$MAIN_EXECUTABLE" << WRAPPER_VARS
export TCL_LIBRARY="\$APP_DIR/lib/tcl$TCL_VERSION"
export TK_LIBRARY="\$APP_DIR/lib/tk$TCL_VERSION"
WRAPPER_VARS

    # Add the rest of the wrapper
    cat >> "$MAIN_EXECUTABLE" << 'WRAPPER_END'

# Set library paths for bundled dylibs (libtommath, etc.)
export DYLD_LIBRARY_PATH="$APP_DIR/Frameworks:$DYLD_LIBRARY_PATH"
export DYLD_FRAMEWORK_PATH="$APP_DIR/Frameworks:$DYLD_FRAMEWORK_PATH"

# Also set DYLD_FALLBACK_LIBRARY_PATH as a backup
export DYLD_FALLBACK_LIBRARY_PATH="$APP_DIR/Frameworks:/usr/lib:/usr/local/lib"

# Execute the real application
exec "$SCRIPT_DIR/$(basename "$0")_real" "$@"
WRAPPER_END

    # Make wrapper executable
    chmod +x "$MAIN_EXECUTABLE"
    
    print_success "Created launcher wrapper with Tcl/Tk environment"
    print_info "TCL_LIBRARY will be set to: Contents/lib/tcl$TCL_VERSION"
    print_info "TK_LIBRARY will be set to: Contents/lib/tk$TCL_VERSION"
    
    return 0
}

# ============================================================================
# BUILD APP
# ============================================================================

build_app() {
    local PY_FILE="$1"
    
    print_header "Building $APP_NAME"
    
    cd "$PROJECT_DIR"
    
    # Check if Python file exists
    if [ ! -f "$PY_FILE" ]; then
        print_error "Python file not found: $PY_FILE"
        exit 1
    fi
    
    print_info "Source: $PY_FILE"
    
    # Extract version from the Python file
    VERSION=$(grep -E "^APP_VERSION\s*=" "$PY_FILE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    if [ -z "$VERSION" ]; then
        VERSION="1.0.0"
    fi
    print_info "Version: $VERSION"
    
    # Generate setup.py with current settings
    generate_setup_py "$PY_FILE" "$VERSION"
    
    # Clean previous build
    clean_build
    
    # Activate venv and build
    activate_venv
    
    # Ensure psutil is installed (v18.0.0 requirement)
    if ! python -c "import psutil" 2>/dev/null; then
        print_info "Installing psutil (required for v18.0.0)..."
        pip install psutil
        if [ $? -ne 0 ]; then
            print_error "Failed to install psutil"
            exit 1
        fi
        print_success "psutil installed"
    fi
    
    echo ""
    echo "Running py2app..."
    echo ""
    python setup.py py2app
    
    BUILD_RESULT=$?
    
    deactivate_venv
    
    if [ $BUILD_RESULT -ne 0 ]; then
        print_error "py2app build failed"
        exit 1
    fi
    
    # Find the built app - handle spaces in name properly
    echo ""
    echo "Looking for built app in dist/..."
    ls -la "$PROJECT_DIR/dist/"
    
    # Use find with -print0 and read to handle spaces
    BUILT_APP_PATH=""
    while IFS= read -r -d '' app; do
        BUILT_APP_PATH="$app"
        break
    done < <(find "$PROJECT_DIR/dist" -maxdepth 1 -name "*.app" -type d -print0 2>/dev/null)
    
    if [ -z "$BUILT_APP_PATH" ]; then
        print_error "No .app found in dist/"
        exit 1
    fi
    
    print_success "App built: $BUILT_APP_PATH"
    
    # Bundle dependencies
    if ! bundle_dependencies "$BUILT_APP_PATH"; then
        print_error "Failed to bundle dependencies"
        exit 1
    fi
    
    # Setup Tcl/Tk environment for the bundled libraries
    if ! setup_tcltk_environment "$BUILT_APP_PATH"; then
        print_warning "Tcl/Tk environment setup had issues"
    fi
    
    # Verify the built app
    verify_app "$BUILT_APP_PATH"
    
    # Code sign the app (prevents "damaged" errors)
    codesign_app "$BUILT_APP_PATH"
    
    # Show final app size
    echo ""
    APP_SIZE=$(du -sh "$BUILT_APP_PATH" | cut -f1)
    print_success "Build complete! App size: $APP_SIZE"
}

# ============================================================================
# INSTALL APP
# ============================================================================

install_app() {
    local SOURCE_APP="$1"
    
    print_header "Installing to $INSTALL_DIR"
    
    if [ ! -d "$SOURCE_APP" ]; then
        print_error "Source app not found: $SOURCE_APP"
        return 1
    fi
    
    # Get the app name from the source
    APP_BASENAME=$(basename "$SOURCE_APP")
    INSTALL_PATH="$INSTALL_DIR/$APP_BASENAME"
    
    print_info "Installing: $APP_BASENAME"
    
    # Remove old installation if exists
    if [ -d "$INSTALL_PATH" ]; then
        print_warning "Removing existing installation..."
        rm -rf "$INSTALL_PATH"
    fi
    
    # Copy new app
    cp -R "$SOURCE_APP" "$INSTALL_DIR/"
    
    if [ -d "$INSTALL_PATH" ]; then
        print_success "Installed to: $INSTALL_PATH"
        
        # Verify ffmpeg and deno are present
        if [ -f "$INSTALL_PATH/Contents/Resources/ffmpeg" ]; then
            print_success "ffmpeg verified"
        else
            print_warning "ffmpeg not found in installed app!"
        fi
        
        if [ -f "$INSTALL_PATH/Contents/Resources/deno" ]; then
            print_success "deno verified"
        else
            print_warning "deno not found in installed app!"
        fi
    else
        print_error "Installation failed"
        return 1
    fi
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    echo ""
    echo -e "${CYAN}+------------------------------------------+${NC}"
    echo -e "${CYAN}|   YouTube 4K Downloader Build System     |${NC}"
    echo -e "${CYAN}+------------------------------------------+${NC}"
    
    # Parse arguments
    case "${1:-}" in
        --help|-h)
            show_help
            exit 0
            ;;
        --update-ytdlp)
            update_ytdlp
            exit 0
            ;;
        --check-updates)
            check_ytdlp_updates
            exit 0
            ;;
        --clean)
            clean_build
            exit 0
            ;;
        *.py)
            # New Python file provided
            if [ -f "$1" ]; then
                print_info "Using Python file: $1"
                MAIN_SCRIPT=$(basename "$1")
                # Copy if source is different from destination
                SOURCE_PATH="$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"
                DEST_PATH="$PROJECT_DIR/$MAIN_SCRIPT"
                if [ "$SOURCE_PATH" != "$DEST_PATH" ]; then
                    cp "$1" "$PROJECT_DIR/"
                    print_success "Copied to project folder"
                else
                    print_info "File already in project folder"
                fi
            else
                print_error "File not found: $1"
                exit 1
            fi
            ;;
        "")
            # No arguments - use default/existing script
            print_info "Using existing script: $MAIN_SCRIPT"
            ;;
        *)
            print_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
    
    # Check for yt-dlp updates
    echo ""
    if check_ytdlp_updates; then
        echo ""
        read -p "Update yt-dlp before building? (y/n) " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            update_ytdlp
        fi
    fi
    
    # Build the app
    cd "$PROJECT_DIR"
    build_app "$MAIN_SCRIPT"
    
    # Ask to install
    echo ""
    read -p "Install to $INSTALL_DIR? (y/n) " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        install_app "$BUILT_APP_PATH"
    fi
    
    # Done!
    print_header "Build Complete!"
    
    echo "Your app is ready:"
    echo ""
    echo "  Built app:  $BUILT_APP_PATH"
    
    APP_BASENAME=$(basename "$BUILT_APP_PATH")
    if [ -d "$INSTALL_DIR/$APP_BASENAME" ]; then
        echo "  Installed:  $INSTALL_DIR/$APP_BASENAME"
    fi
    echo ""
    print_success "Done!"
}

# Run main
main "$@"
