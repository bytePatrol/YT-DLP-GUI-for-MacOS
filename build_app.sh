#!/bin/bash
#
# build_app.sh - Complete build system for YouTube 4K Downloader
# 
# This script handles:
#   - Generating setup.py configuration
#   - Updating yt-dlp to the latest version
#   - Building the macOS app with py2app
#   - Bundling ffmpeg and deno for a self-contained app
#   - Installing to Applications folder
#
# Usage:
#   ./build_app.sh                      # Build with current .py file
#   ./build_app.sh yt_dlp_gui_v18.py    # Build with a new version
#   ./build_app.sh --update-ytdlp       # Just update yt-dlp, no build
#   ./build_app.sh --help               # Show help
#
# Author: bytePatrol
#

# ============================================================================
# CONFIGURATION
# ============================================================================

# Auto-detect project directory (where this script is located)
PROJECT_DIR="$(cd "$(dirname "$0")" && pwd)"
VENV_DIR="$PROJECT_DIR/venv"
MAIN_SCRIPT="yt_dlp_gui_v17_9_0.py"  # Default script name
APP_NAME="YouTube 4K Downloader"
BUNDLE_ID="com.bytepatrol.youtube4kdownloader"
INSTALL_DIR="/Applications"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Global variable to store built app path
BUILT_APP_PATH=""

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

print_header() {
    echo ""
    echo -e "${CYAN}==========================================${NC}"
    echo -e "${CYAN}$1${NC}"
    echo -e "${CYAN}==========================================${NC}"
    echo ""
}

print_success() {
    echo -e "${GREEN}[OK] $1${NC}"
}

print_error() {
    echo -e "${RED}[ERROR] $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}[WARN] $1${NC}"
}

print_info() {
    echo -e "${BLUE}[INFO] $1${NC}"
}

show_help() {
    echo ""
    echo "YouTube 4K Downloader Build Script"
    echo ""
    echo "Usage:"
    echo "  ./build_app.sh                      Build with current .py file"
    echo "  ./build_app.sh <file.py>            Build with a new Python file"
    echo "  ./build_app.sh --update-ytdlp       Just update yt-dlp (no build)"
    echo "  ./build_app.sh --check-updates      Check for yt-dlp updates"
    echo "  ./build_app.sh --clean              Clean build artifacts"
    echo "  ./build_app.sh --help               Show this help"
    echo ""
    echo "Examples:"
    echo "  ./build_app.sh yt_dlp_gui_v18.py    Build new version"
    echo "  ./build_app.sh --update-ytdlp       Update yt-dlp before building"
    echo ""
}

activate_venv() {
    if [ ! -f "$VENV_DIR/bin/activate" ]; then
        print_warning "Virtual environment not found at $VENV_DIR"
        print_info "Creating virtual environment..."
        
        python3 -m venv "$VENV_DIR"
        
        if [ $? -ne 0 ]; then
            print_error "Failed to create virtual environment"
            exit 1
        fi
        
        print_success "Virtual environment created"
        
        # Activate and install dependencies
        source "$VENV_DIR/bin/activate"
        
        print_info "Installing required packages..."
        pip install --upgrade pip
        pip install py2app customtkinter pillow requests yt-dlp darkdetect idna urllib3 charset-normalizer certifi
        
        if [ $? -ne 0 ]; then
            print_error "Failed to install dependencies"
            exit 1
        fi
        
        print_success "All dependencies installed"
    else
        source "$VENV_DIR/bin/activate"
        print_success "Virtual environment activated"
    fi
}

deactivate_venv() {
    if command -v deactivate &> /dev/null; then
        deactivate 2>/dev/null || true
    fi
}

# ============================================================================
# GENERATE SETUP.PY
# ============================================================================

generate_setup_py() {
    local PY_FILE="$1"
    local VERSION="$2"
    
    print_info "Generating setup.py for $PY_FILE (v$VERSION)"
    
    cat > "$PROJECT_DIR/setup.py" << 'SETUP_EOF'
"""
Setup script for creating a macOS .app bundle for YouTube 4K Downloader
Auto-generated by build_app.sh
"""

from setuptools import setup
import os
import sys
import tkinter
import shutil

# Path to your app icon (in assets folder)
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
ICON_PATH = os.path.join(SCRIPT_DIR, 'assets', 'icon.icns')

# Verify icon exists
if os.path.isfile(ICON_PATH):
    print(f"[OK] Found icon at: {ICON_PATH}")
else:
    print(f"[WARN] Icon not found at: {ICON_PATH}")
    ICON_PATH = None

# Find Tcl/Tk library paths for bundling
def find_tcl_tk():
    """Find Tcl/Tk frameworks/libraries to bundle."""
    tcl_paths = []
    
    # Get the Tcl/Tk library that Python is actually using
    try:
        tcl_lib = tkinter.Tcl().eval('info library')
        if tcl_lib and os.path.exists(tcl_lib):
            # Get parent directories to find the framework
            tcl_root = os.path.dirname(os.path.dirname(tcl_lib))
            if os.path.exists(tcl_root):
                print(f"[OK] Found Tcl at: {tcl_root}")
                tcl_paths.append(tcl_root)
    except Exception as e:
        print(f"[WARN] Could not detect Tcl/Tk path: {e}")
    
    # Also check common Homebrew locations
    homebrew_paths = [
        '/opt/homebrew/opt/tcl-tk/lib',  # Apple Silicon
        '/usr/local/opt/tcl-tk/lib',      # Intel
    ]
    for path in homebrew_paths:
        if os.path.isdir(path):
            print(f"[OK] Found Homebrew Tcl/Tk at: {path}")
            tcl_paths.append(path)
            break
    
    return tcl_paths

tcl_tk_paths = find_tcl_tk()

SETUP_EOF

    # Now append the rest with variable substitution
    cat >> "$PROJECT_DIR/setup.py" << SETUP_EOF

APP = ['$PY_FILE']
DATA_FILES = []

# Build frameworks list for Tcl/Tk
frameworks_to_include = []
for tcl_path in tcl_tk_paths:
    tcl_fw = os.path.join(tcl_path, 'Tcl.framework')
    tk_fw = os.path.join(tcl_path, 'Tk.framework')
    if os.path.isdir(tcl_fw):
        frameworks_to_include.append(tcl_fw)
    if os.path.isdir(tk_fw):
        frameworks_to_include.append(tk_fw)

if frameworks_to_include:
    print(f"[OK] Will bundle frameworks: {frameworks_to_include}")

OPTIONS = {
    'argv_emulation': False,
    'iconfile': ICON_PATH,
    'plist': {
        'CFBundleName': '$APP_NAME',
        'CFBundleDisplayName': '$APP_NAME',
        'CFBundleGetInfoString': "Modern YouTube downloader for macOS - 100% Standalone",
        'CFBundleIdentifier': "$BUNDLE_ID",
        'CFBundleVersion': "$VERSION",
        'CFBundleShortVersionString': "$VERSION",
        'NSHumanReadableCopyright': "Copyright 2025 bytePatrol. All rights reserved.",
        'NSHighResolutionCapable': True,
        'LSMinimumSystemVersion': '10.13',
    },
    'frameworks': frameworks_to_include,
    'packages': [
        'customtkinter',
        'tkinter',
        'PIL',
        'requests',
        'certifi',
        'charset_normalizer',
        'yt_dlp',
        'idna',
        'urllib3',
        'darkdetect',
    ],
    'includes': [
        'subprocess',
        'json',
        'threading',
        'queue',
        'pathlib',
        'dataclasses',
        'typing',
        'enum',
        'hashlib',
        'tempfile',
        'shlex',
        'urllib.request',
        '_tkinter',
        'tkinter',
        'tkinter.ttk',
        'tkinter.filedialog',
        'tkinter.messagebox',
        'PIL.Image',
        'PIL.ImageTk',
    ],
    'excludes': [
        'numpy',
        'scipy',
        'matplotlib',
        'pandas',
        'IPython',
        'jupyter',
        'notebook',
        'test',
        'tests',
    ],
    'semi_standalone': False,
    'site_packages': True,
    'strip': False,
}

setup(
    name='$APP_NAME',
    app=APP,
    data_files=DATA_FILES,
    options={'py2app': OPTIONS},
    setup_requires=['py2app'],
)
SETUP_EOF

    print_success "setup.py generated"
}

# ============================================================================
# UPDATE YT-DLP
# ============================================================================

check_ytdlp_updates() {
    print_header "Checking for yt-dlp Updates"
    
    activate_venv
    
    CURRENT_VERSION=$(pip show yt-dlp 2>/dev/null | grep "Version:" | awk '{print $2}')
    echo "Current version: $CURRENT_VERSION"
    
    # Check PyPI for latest version
    LATEST_VERSION=$(pip index versions yt-dlp 2>/dev/null | grep -oE '[0-9]{4}\.[0-9]{1,2}\.[0-9]{1,2}' | head -1)
    
    if [ -z "$LATEST_VERSION" ]; then
        # Fallback method
        LATEST_VERSION=$(pip install yt-dlp== 2>&1 | grep -oE '[0-9]{4}\.[0-9]{1,2}\.[0-9]{1,2}' | tail -1)
    fi
    
    echo "Latest version:  $LATEST_VERSION"
    
    deactivate_venv
    
    if [ "$CURRENT_VERSION" = "$LATEST_VERSION" ]; then
        print_success "yt-dlp is up to date!"
        return 1  # No update needed
    else
        print_warning "Update available: $CURRENT_VERSION -> $LATEST_VERSION"
        return 0  # Update available
    fi
}

update_ytdlp() {
    print_header "Updating yt-dlp"
    
    activate_venv
    
    BEFORE_VERSION=$(pip show yt-dlp 2>/dev/null | grep "Version:" | awk '{print $2}')
    print_info "Current version: $BEFORE_VERSION"
    
    echo ""
    echo "Updating yt-dlp..."
    pip install --upgrade yt-dlp
    
    AFTER_VERSION=$(pip show yt-dlp 2>/dev/null | grep "Version:" | awk '{print $2}')
    
    echo ""
    if [ "$BEFORE_VERSION" = "$AFTER_VERSION" ]; then
        print_success "yt-dlp is already at the latest version: $AFTER_VERSION"
    else
        print_success "yt-dlp updated: $BEFORE_VERSION -> $AFTER_VERSION"
    fi
    
    deactivate_venv
}

# ============================================================================
# CLEAN BUILD
# ============================================================================

clean_build() {
    print_header "Cleaning Build Artifacts"
    
    cd "$PROJECT_DIR"
    
    if [ -d "build" ]; then
        rm -rf build
        print_success "Removed build/"
    fi
    
    if [ -d "dist" ]; then
        rm -rf dist
        print_success "Removed dist/"
    fi
    
    # Remove .pyc files
    find . -type f -name "*.pyc" -delete 2>/dev/null || true
    find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
    
    print_success "Clean complete"
}

# ============================================================================
# BUNDLE DEPENDENCIES (ffmpeg + deno + Tcl/Tk)
# ============================================================================

bundle_dependencies() {
    local APP_PATH="$1"
    local RESOURCES_DIR="$APP_PATH/Contents/Resources"
    local FRAMEWORKS_DIR="$APP_PATH/Contents/Frameworks"
    
    print_header "Bundling Dependencies (ffmpeg + deno + Tcl/Tk)"
    
    echo "App path: $APP_PATH"
    echo "Resources dir: $RESOURCES_DIR"
    
    if [ ! -d "$APP_PATH" ]; then
        print_error "App not found at: $APP_PATH"
        echo "Contents of dist/:"
        ls -la "$PROJECT_DIR/dist/" 2>/dev/null || echo "dist/ not found"
        return 1
    fi
    
    if [ ! -d "$RESOURCES_DIR" ]; then
        print_error "Resources directory not found at: $RESOURCES_DIR"
        return 1
    fi
    
    # Create Frameworks directory if it doesn't exist
    mkdir -p "$FRAMEWORKS_DIR"
    
    TEMP_DIR=$(mktemp -d)
    cd "$TEMP_DIR"
    
    # --- Bundle Tcl/Tk Frameworks ---
    echo ""
    echo "Bundling Tcl/Tk frameworks..."
    
    # First check if already bundled by py2app
    if [ -d "$FRAMEWORKS_DIR/Tcl.framework" ] && [ -d "$FRAMEWORKS_DIR/Tk.framework" ]; then
        print_success "Tcl/Tk already bundled by py2app"
    else
        # Try to find and copy from various sources
        TCL_FRAMEWORK=""
        TK_FRAMEWORK=""
        
        # Check Homebrew tcl-tk (Apple Silicon)
        if [ -d "/opt/homebrew/opt/tcl-tk/lib/Tcl.framework" ]; then
            TCL_FRAMEWORK="/opt/homebrew/opt/tcl-tk/lib/Tcl.framework"
            TK_FRAMEWORK="/opt/homebrew/opt/tcl-tk/lib/Tk.framework"
            echo "Found Tcl/Tk from Homebrew (Apple Silicon)"
        # Check Homebrew tcl-tk (Intel)
        elif [ -d "/usr/local/opt/tcl-tk/lib/Tcl.framework" ]; then
            TCL_FRAMEWORK="/usr/local/opt/tcl-tk/lib/Tcl.framework"
            TK_FRAMEWORK="/usr/local/opt/tcl-tk/lib/Tk.framework"
            echo "Found Tcl/Tk from Homebrew (Intel)"
        # Check system location (some macOS versions)
        elif [ -d "/Library/Frameworks/Tcl.framework" ]; then
            TCL_FRAMEWORK="/Library/Frameworks/Tcl.framework"
            TK_FRAMEWORK="/Library/Frameworks/Tk.framework"
            echo "Found Tcl/Tk from /Library/Frameworks"
        fi
        
        if [ -n "$TCL_FRAMEWORK" ] && [ -d "$TCL_FRAMEWORK" ]; then
            # Copy frameworks to app bundle
            cp -R "$TCL_FRAMEWORK" "$FRAMEWORKS_DIR/" 2>/dev/null && print_success "Tcl.framework bundled"
            cp -R "$TK_FRAMEWORK" "$FRAMEWORKS_DIR/" 2>/dev/null && print_success "Tk.framework bundled"
        else
            # Download pre-built Tcl/Tk frameworks
            print_info "Tcl/Tk not found locally, downloading..."
            
            ARCH=$(uname -m)
            if [ "$ARCH" = "arm64" ]; then
                TCL_TK_URL="https://github.com/nicholaswilson/macos-tcl-tk/releases/download/v8.6.14/tcl-tk-8.6.14-arm64.tar.gz"
            else
                TCL_TK_URL="https://github.com/nicholaswilson/macos-tcl-tk/releases/download/v8.6.14/tcl-tk-8.6.14-x86_64.tar.gz"
            fi
            
            echo "Downloading Tcl/Tk for $ARCH..."
            if curl -L --progress-bar "$TCL_TK_URL" -o tcl-tk.tar.gz 2>/dev/null; then
                tar -xzf tcl-tk.tar.gz 2>/dev/null
                
                # Find and copy the frameworks
                if [ -d "Tcl.framework" ]; then
                    cp -R Tcl.framework "$FRAMEWORKS_DIR/"
                    cp -R Tk.framework "$FRAMEWORKS_DIR/"
                    print_success "Tcl/Tk downloaded and bundled"
                elif [ -d "lib/Tcl.framework" ]; then
                    cp -R lib/Tcl.framework "$FRAMEWORKS_DIR/"
                    cp -R lib/Tk.framework "$FRAMEWORKS_DIR/"
                    print_success "Tcl/Tk downloaded and bundled"
                else
                    print_warning "Downloaded Tcl/Tk but couldn't find frameworks"
                    ls -la
                fi
            else
                print_warning "Could not download Tcl/Tk - trying alternative source..."
                
                # Alternative: Download from python.org's macOS installer resources
                # The app may still work if the user's system has Tcl/Tk
                print_warning "Tcl/Tk not bundled - users may need 'brew install tcl-tk'"
            fi
        fi
    fi
    
    # --- Install FFmpeg ---
    echo ""
    echo "Downloading static ffmpeg..."
    if curl -L --progress-bar "https://evermeet.cx/ffmpeg/getrelease/ffmpeg/zip" -o ffmpeg.zip; then
        unzip -q ffmpeg.zip
        
        if [ -f "ffmpeg" ]; then
            cp ffmpeg "$RESOURCES_DIR/ffmpeg"
            chmod +x "$RESOURCES_DIR/ffmpeg"
            print_success "FFmpeg installed ($(ls -lh "$RESOURCES_DIR/ffmpeg" | awk '{print $5}'))"
        else
            print_error "FFmpeg not found in zip"
            cd /
            rm -rf "$TEMP_DIR"
            return 1
        fi
    else
        print_error "FFmpeg download failed"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # --- Install Deno ---
    ARCH=$(uname -m)
    if [ "$ARCH" = "arm64" ]; then
        DENO_ARCH="aarch64"
    else
        DENO_ARCH="x86_64"
    fi
    
    echo ""
    echo "Downloading deno for $DENO_ARCH..."
    if curl -L --progress-bar "https://github.com/denoland/deno/releases/latest/download/deno-${DENO_ARCH}-apple-darwin.zip" -o deno.zip; then
        unzip -q -o deno.zip
        
        if [ -f "deno" ]; then
            cp deno "$RESOURCES_DIR/deno"
            chmod +x "$RESOURCES_DIR/deno"
            print_success "Deno installed ($(ls -lh "$RESOURCES_DIR/deno" | awk '{print $5}'))"
        else
            print_error "Deno not found in zip"
            cd /
            rm -rf "$TEMP_DIR"
            return 1
        fi
    else
        print_error "Deno download failed"
        cd /
        rm -rf "$TEMP_DIR"
        return 1
    fi
    
    # Cleanup
    cd /
    rm -rf "$TEMP_DIR"
    
    echo ""
    print_success "All dependencies bundled successfully!"
    return 0
}

# ============================================================================
# VERIFY APP
# ============================================================================

verify_app() {
    local APP_PATH="$1"
    
    print_header "Verifying Built App"
    
    if [ ! -d "$APP_PATH" ]; then
        print_error "App not found at: $APP_PATH"
        return 1
    fi
    
    local RESOURCES_DIR="$APP_PATH/Contents/Resources"
    local FRAMEWORKS_DIR="$APP_PATH/Contents/Frameworks"
    local ERRORS=0
    
    # Check bundled executables
    echo "Checking bundled executables..."
    if [ -f "$RESOURCES_DIR/ffmpeg" ]; then
        print_success "ffmpeg present"
    else
        print_error "ffmpeg missing!"
        ERRORS=$((ERRORS + 1))
    fi
    
    if [ -f "$RESOURCES_DIR/deno" ]; then
        print_success "deno present"
    else
        print_error "deno missing!"
        ERRORS=$((ERRORS + 1))
    fi
    
    # Check Tcl/Tk frameworks
    echo ""
    echo "Checking Tcl/Tk frameworks..."
    if [ -d "$FRAMEWORKS_DIR/Tcl.framework" ]; then
        print_success "Tcl.framework present"
    else
        print_warning "Tcl.framework not bundled (may cause issues on some Macs)"
    fi
    
    if [ -d "$FRAMEWORKS_DIR/Tk.framework" ]; then
        print_success "Tk.framework present"
    else
        print_warning "Tk.framework not bundled (may cause issues on some Macs)"
    fi
    
    # Check for Python packages in site-packages
    echo ""
    echo "Checking Python packages..."
    local SITE_PACKAGES=$(find "$APP_PATH/Contents/Resources/lib" -name "site-packages" -type d 2>/dev/null | head -1)
    
    if [ -n "$SITE_PACKAGES" ]; then
        local PACKAGES=("customtkinter" "PIL" "requests" "yt_dlp" "certifi")
        
        for pkg in "${PACKAGES[@]}"; do
            if [ -d "$SITE_PACKAGES/$pkg" ] || ls "$SITE_PACKAGES" | grep -qi "^${pkg}" 2>/dev/null; then
                print_success "$pkg"
            else
                print_error "$pkg missing!"
                ERRORS=$((ERRORS + 1))
            fi
        done
    else
        print_warning "Could not locate site-packages directory"
    fi
    
    # Check main executable
    echo ""
    echo "Checking main executable..."
    local EXECUTABLE="$APP_PATH/Contents/MacOS/$APP_NAME"
    if [ -f "$EXECUTABLE" ]; then
        local ARCH=$(file "$EXECUTABLE" | grep -o 'arm64\|x86_64' | head -1)
        local CURRENT_ARCH=$(uname -m)
        print_success "Executable found (architecture: $ARCH)"
        
        if [ "$ARCH" != "$CURRENT_ARCH" ]; then
            print_warning "Built for $ARCH but running on $CURRENT_ARCH"
        fi
    else
        print_error "Main executable not found!"
        ERRORS=$((ERRORS + 1))
    fi
    
    echo ""
    if [ $ERRORS -eq 0 ]; then
        print_success "All checks passed!"
        return 0
    else
        print_error "$ERRORS error(s) found - app may not launch correctly"
        return 1
    fi
}

# ============================================================================
# CODE SIGN APP (Ad-hoc signing to prevent "damaged" errors)
# ============================================================================

codesign_app() {
    local APP_PATH="$1"
    
    print_header "Code Signing App (Ad-hoc)"
    
    if [ ! -d "$APP_PATH" ]; then
        print_error "App not found: $APP_PATH"
        return 1
    fi
    
    echo "Signing with ad-hoc signature..."
    echo "(This prevents 'app is damaged' errors on other Macs)"
    echo ""
    
    # Remove any existing signatures and quarantine attributes
    xattr -cr "$APP_PATH" 2>/dev/null || true
    
    # Sign all nested components first (frameworks, dylibs, etc.)
    find "$APP_PATH" -type f \( -name "*.dylib" -o -name "*.so" -o -name "*.framework" \) -exec codesign --force --sign - {} \; 2>/dev/null || true
    
    # Sign the main executable
    codesign --force --deep --sign - "$APP_PATH" 2>&1
    
    if [ $? -eq 0 ]; then
        print_success "App signed successfully"
        
        # Verify signature
        if codesign --verify --verbose "$APP_PATH" 2>&1 | grep -q "valid"; then
            print_success "Signature verified"
        fi
    else
        print_warning "Code signing had issues (app may still work)"
    fi
    
    # Remove quarantine attribute (in case it got re-added)
    xattr -dr com.apple.quarantine "$APP_PATH" 2>/dev/null || true
    
    return 0
}

# ============================================================================
# BUILD APP
# ============================================================================

build_app() {
    local PY_FILE="$1"
    
    print_header "Building $APP_NAME"
    
    cd "$PROJECT_DIR"
    
    # Check if Python file exists
    if [ ! -f "$PY_FILE" ]; then
        print_error "Python file not found: $PY_FILE"
        exit 1
    fi
    
    print_info "Source: $PY_FILE"
    
    # Extract version from the Python file
    VERSION=$(grep -E "^APP_VERSION\s*=" "$PY_FILE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    if [ -z "$VERSION" ]; then
        VERSION="1.0.0"
    fi
    print_info "Version: $VERSION"
    
    # Generate setup.py with current settings
    generate_setup_py "$PY_FILE" "$VERSION"
    
    # Clean previous build
    clean_build
    
    # Activate venv and build
    activate_venv
    
    echo ""
    echo "Running py2app..."
    echo ""
    python setup.py py2app
    
    BUILD_RESULT=$?
    
    deactivate_venv
    
    if [ $BUILD_RESULT -ne 0 ]; then
        print_error "py2app build failed"
        exit 1
    fi
    
    # Find the built app - handle spaces in name properly
    echo ""
    echo "Looking for built app in dist/..."
    ls -la "$PROJECT_DIR/dist/"
    
    # Use find with -print0 and read to handle spaces
    BUILT_APP_PATH=""
    while IFS= read -r -d '' app; do
        BUILT_APP_PATH="$app"
        break
    done < <(find "$PROJECT_DIR/dist" -maxdepth 1 -name "*.app" -type d -print0 2>/dev/null)
    
    if [ -z "$BUILT_APP_PATH" ]; then
        print_error "No .app found in dist/"
        exit 1
    fi
    
    print_success "App built: $BUILT_APP_PATH"
    
    # Bundle dependencies
    if ! bundle_dependencies "$BUILT_APP_PATH"; then
        print_error "Failed to bundle dependencies"
        exit 1
    fi
    
    # Verify the built app
    verify_app "$BUILT_APP_PATH"
    
    # Code sign the app (prevents "damaged" errors)
    codesign_app "$BUILT_APP_PATH"
    
    # Show final app size
    echo ""
    APP_SIZE=$(du -sh "$BUILT_APP_PATH" | cut -f1)
    print_success "Build complete! App size: $APP_SIZE"
}

# ============================================================================
# INSTALL APP
# ============================================================================

install_app() {
    local SOURCE_APP="$1"
    
    print_header "Installing to $INSTALL_DIR"
    
    if [ ! -d "$SOURCE_APP" ]; then
        print_error "Source app not found: $SOURCE_APP"
        return 1
    fi
    
    # Get the app name from the source
    APP_BASENAME=$(basename "$SOURCE_APP")
    INSTALL_PATH="$INSTALL_DIR/$APP_BASENAME"
    
    print_info "Installing: $APP_BASENAME"
    
    # Remove old installation if exists
    if [ -d "$INSTALL_PATH" ]; then
        print_warning "Removing existing installation..."
        rm -rf "$INSTALL_PATH"
    fi
    
    # Copy new app
    cp -R "$SOURCE_APP" "$INSTALL_DIR/"
    
    if [ -d "$INSTALL_PATH" ]; then
        print_success "Installed to: $INSTALL_PATH"
        
        # Verify ffmpeg and deno are present
        if [ -f "$INSTALL_PATH/Contents/Resources/ffmpeg" ]; then
            print_success "ffmpeg verified"
        else
            print_warning "ffmpeg not found in installed app!"
        fi
        
        if [ -f "$INSTALL_PATH/Contents/Resources/deno" ]; then
            print_success "deno verified"
        else
            print_warning "deno not found in installed app!"
        fi
    else
        print_error "Installation failed"
        return 1
    fi
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    echo ""
    echo -e "${CYAN}+------------------------------------------+${NC}"
    echo -e "${CYAN}|   YouTube 4K Downloader Build System     |${NC}"
    echo -e "${CYAN}+------------------------------------------+${NC}"
    
    # Parse arguments
    case "${1:-}" in
        --help|-h)
            show_help
            exit 0
            ;;
        --update-ytdlp)
            update_ytdlp
            exit 0
            ;;
        --check-updates)
            check_ytdlp_updates
            exit 0
            ;;
        --clean)
            clean_build
            exit 0
            ;;
        *.py)
            # New Python file provided
            if [ -f "$1" ]; then
                print_info "Using Python file: $1"
                MAIN_SCRIPT=$(basename "$1")
                # Copy if source is different from destination
                SOURCE_PATH="$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"
                DEST_PATH="$PROJECT_DIR/$MAIN_SCRIPT"
                if [ "$SOURCE_PATH" != "$DEST_PATH" ]; then
                    cp "$1" "$PROJECT_DIR/"
                    print_success "Copied to project folder"
                else
                    print_info "File already in project folder"
                fi
            else
                print_error "File not found: $1"
                exit 1
            fi
            ;;
        "")
            # No arguments - use default/existing script
            print_info "Using existing script: $MAIN_SCRIPT"
            ;;
        *)
            print_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
    
    # Check for yt-dlp updates
    echo ""
    if check_ytdlp_updates; then
        echo ""
        read -p "Update yt-dlp before building? (y/n) " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            update_ytdlp
        fi
    fi
    
    # Build the app
    cd "$PROJECT_DIR"
    build_app "$MAIN_SCRIPT"
    
    # Ask to install
    echo ""
    read -p "Install to $INSTALL_DIR? (y/n) " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        install_app "$BUILT_APP_PATH"
    fi
    
    # Done!
    print_header "Build Complete!"
    
    echo "Your app is ready:"
    echo ""
    echo "  Built app:  $BUILT_APP_PATH"
    
    APP_BASENAME=$(basename "$BUILT_APP_PATH")
    if [ -d "$INSTALL_DIR/$APP_BASENAME" ]; then
        echo "  Installed:  $INSTALL_DIR/$APP_BASENAME"
    fi
    echo ""
    print_success "Done!"
}

# Run main
main "$@"
